#define F_CPU 16000000
#define __AVR_ATmega2560__
#ifndef __AVR_ATmega2560__



void mTimer(int count);
#endif
//void mTimer(int count);
#define BUAD 9600
#define BRC ((F_CPU/16/BUAD) - 1)
#include <stdio.h>
#include <stdlib.h> // the header of the general-purpose standard library of C programming language
#include <avr/io.h> // the header of the I/O port library

#include <util/delay_basic.h> // header of the delay functions
#include <util/delay.h>

#include "lcd_test.h"
#include "lcd.h"
#include "ffft.h"
//#include "test3.c"
#include "Sample_freq - Copy.c"

#include <avr/interrupt.h> // header for interrupts


volatile unsigned int ADC_result;
volatile unsigned int ADC_result_flag;

int16_t capture[FFT_N]; /* Wave captureing buffer */ 
complex_t bfly_buff[FFT_N]; /* FFT buffer */ 
uint16_t spektrum[FFT_N/2]; /* Spectrum output buffer */

#define ADCpin1 0x61

void mTimer (int count)
{
   /***
      Setup Timer1 as a ms timer
	  Using polling method not Interrupt Driven
   ***/
   sei();
   int i;

   i = 0;

   TCCR1B |= _BV (CS11);  // Set prescaler (/8) clock 16MHz/8 -> 2MHz
   /* Set the Waveform gen. mode bit description to clear
     on compare mode only */
   TCCR1B |= _BV(WGM12);

   /* Set output compare register for 2000 cycles, 1ms */
   OCR1A = 0x07D0;
 
   /* Initialize Timer1 to zero */
   TCNT1 = 0x0000;

   /* Enable the output compare interrupt */
   //TIMSK1 |= _BV(OCIE1A);  //remove if global interrups is set (sei())

   /* Clear the Timer1 interrupt flag and begin timing */
   TIFR1 |= _BV(OCF1A);

   /* Poll the timer to determine when the timer has reached 1ms */
   while (i < count)
   {
      while ((TIFR1 & 0x02) != 0x02);
	
	   /* Clear the interrupt flag by WRITING a ONE to the bit */
	   TIFR1 |= _BV(OCF1A);
	   i++;
   } /* while */
   TCCR1B &= ~_BV (CS11);  //  disable prescalar, no Clock
   return;
}  /* mTimer */



int main(int argc, char *argv[])
{ 
   test_LCD();
   //uint16_t temp;
             
    //mTimer(500);
	//LCDWriteString("ADC Setting");

   cli();
   ADCSRA |= _BV(ADEN); // enable ADC 
   ADCSRA |= _BV(ADIE); // enable interrupt of ADC 
   ADMUX |= _BV(ADLAR) | _BV(REFS0) | _BV(MUX0);


   UBRR0H = (BRC >> 8);
   UBRR0L = BRC;
   //UCSR0B = (1 << TXEN0);
   UCSR0B = (1 << TXEN0);
   UCSR0C = (1 << UCSZ01) | (1 << UCSZ00);

   sei();
   ADCSRA |= _BV(ADSC);
   //ADMUX |= ~(_BV(MUX0));
   LCDClear();
   LCDWriteString("other Text");
   
    while (1)
    {
      UDR0 = '8';
      mTimer(1000);
      //LCDClear();
      //LCDWriteString("Flag not set");
      //if (ADC_result_flag)
     // {
         //test_LCD();
         // fft_input(testing_wav, bfly_buff);
         // fft_execute(bfly_buff);
         // fft_output(bfly_buff, spektrum);
         
         // for (uint8_t i=0;i<FFT_N/2;i++)
         // {
         //    temp = spektrum[i];
         //   //sprintf(buf1,"%u",i);
         //    // uart_sendstring(buf1);
         //    // uart_send(':');
         //   // sprintf(buf1,"%u",temp);

         
         //    LCDClear();
         //    LCDWriteStringXY(0,0,"FFT: ");
         //    LCDWriteIntXY(5,0,temp,4);
            
          
         //    mTimer(1000);
         // }

         //LCDWriteStringXY(0,1,"ADC 1: ");
         // LCDWriteStringXY(0,0,"ADC 0: ");
         // LCDWriteStringXY(0,1,"ADC 1: ");
         
      //    //LCDWriteString("ADC Setting");
      //   // LCDWriteInt(ADC_result,5);
      //    ADC_result_flag = 0x00;
      //    mTimer(1000);
      //    // swap channels for sampling
         
      //    if ((ADMUX&ADCpin1) == 0x61)
      //    {
      //       //LCDWriteIntXY(7,0,ADC_result,4);
      //       //LCDWriteStringXY(7,0,"firsttest");
      //       LCDWriteInt(capture[3],6);
      //       //ADMUX |= (_BV(MUX1));
      //       //ADMUX &= (~(_BV(MUX0)));
      //    }
      //    else
      //      // LCDWriteIntXY(7,1,ADC_result,4);
      //       //LCDWriteStringXY(7,1,"second");
      //    ADMUX ^= _BV(MUX0);
      //   //ADMUX |= (_BV(MUX1));
         
      //    ADCSRA |= _BV(ADSC);
      //    mTimer(1000);
      //    //printf("Main loop");
      //    //printf("%d", ADC_result);
      //    int i;
		//    for(i = 0; i != FFT_N; i++)
		// 	   capture[i] = ADC_result - 512;

         

     // }

    }
    return (0); // This line returns a 0 value to the calling program 
    //sei();
// generally means no error was returned 
}

ISR(ADC_vect)
{
   ADC_result = ADCH;
   ADC_result_flag = 1;
}